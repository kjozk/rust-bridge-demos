# rust-bridge-demos

このリポジトリは、**Rust で実装したコアライブラリを、複数の言語・ランタイムから再利用するための実践的なデモ集**です。

単なるサンプルではなく、

- 設計の分離
- データモデルの扱い
- ブリッジ方式ごとの特性

を比較・検証できる構成を目的としています。

---

## 目的

本リポジトリの目的は以下の通りです。

- Rust を **コアロジックの実装言語**として固定する
- 異なるブリッジ方式を **並列に比較**する
- 実務でそのまま応用可能な構成を提示する

以下のような疑問に答えることを意図しています。

- PyO3 と MessagePack + FFI は何が違うのか
- IF 用モデルはどこで定義すべきか
- 言語ごとにどこまで責務を分離すべきか

---

## 全体構成

```
rust-bridge-demos/
├─ core/ # Rust コアライブラリ（domain + APIモデル）
├─ py-bridge/ # Rust → PyO3 ブリッジ
├─ py-demo/ # Python デモアプリケーション
├─ msgpack-bridge/ # Rust → MessagePack（C ABI）
├─ dotnet-bridge/ # C# ラッパー（P/Invoke）
├─ dotnet-demo/ # WPF デモアプリケーション
└─ docs/ # 設計メモ・補足資料
```

---

## Rust コア (`core/`)

- ビジネスロジック・計算ロジックの本体
- **特定の言語や UI に依存しない**
- IF 用の API モデルは domain モデルと分離

Rust は「唯一の真実（Single Source of Truth）」として扱います。

---

## Python 向けブリッジ（PyO3）

### `py-bridge/`

- Rust コアを PyO3 で Python モジュールとして公開
- Python からは通常のライブラリとして利用可能

### `py-demo/`

- Python から Rust ライブラリを呼び出すデモ
- 可視化や簡易 UI を想定

---

## .NET 向けブリッジ（MessagePack + C ABI）

### `msgpack-bridge/`

- Rust の C ABI を公開
- 入出力は **MessagePack バイナリ**
- 言語非依存な IF を提供

### `dotnet-bridge/`

- C# 側の P/Invoke ラッパー
- MessagePack のシリアライズ／デシリアライズを担当
- ネイティブ呼び出しを完全に隠蔽

### `dotnet-demo/`

- WPF を用いたデモアプリケーション
- Rust エンジンの結果を視覚的に確認可能

---

## なぜこの構成なのか

### Rust を中心に据える理由

- 高いパフォーマンス
- 明確な所有権モデル
- 安定した ABI 設計が可能

### ブリッジ層を分ける理由

- 各言語の責務を明確にする
- IF モデルの変更影響を局所化する
- 将来の拡張（macOS / Linux / Web 等）を容易にする

---

## このリポジトリで扱わないこと

- UI フレームワークの詳細な解説
- ネットワーク通信（HTTP / gRPC）
- 巨大なフレームワーク依存

あくまで **「Rust ライブラリをどう再利用するか」** に焦点を当てています。

---

## 想定読者

- Rust をコアにしたライブラリ設計を考えている方
- Python / C# から Rust を使いたい方
- FFI やデータ境界設計に関心のある方

---

## ライセンス

このリポジトリはサンプル・デモ用途を想定しています。
ライセンスについては `LICENSE` を参照してください。
